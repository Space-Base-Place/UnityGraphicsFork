#include "Math.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl"

struct appdata
{
    float4 vertex : POSITION;
    float4 uv : TEXCOORD0;
};

struct v2f
{
    float4 pos : SV_POSITION;
    float2 uv : TEXCOORD0;
    float3 viewVector : TEXCOORD1;
};

v2f vert(appdata v)
{
    v2f output;
    output.pos = TransformObjectToHClip(v.vertex);
    output.uv = v.uv;
					// Camera space matches OpenGL convention where cam forward is -z. In unity forward is positive z.
					// (https://docs.unity3d.com/ScriptReference/Camera-cameraToWorldMatrix.html)
    float3 viewVector = mul(unity_CameraInvProjection, float4(v.uv.xy * 2 - 1, 0, -1));
    output.viewVector = mul(unity_CameraToWorld, float4(viewVector, 0));
    return output;
}

			//float4 testColor;

TEXTURE2D_X(_BlueNoise);
SAMPLER(sampler_BlueNoise);
float4 _BlueNoise_TexelSize;

TEXTURE2D_X(_MainTex);
SAMPLER(sampler_MainTex);
TEXTURE2D_X(_BakedOpticalDepth);
SAMPLER(sampler_BakedOpticalDepth);

float3 planetCentre;
float atmosphereRadius;
float oceanRadius;
float planetRadius;

			// Paramaters
int numInScatteringPoints;
//int numOpticalDepthPoints;
float intensity;
float4 scatteringCoefficients;
float ditherStrength;
float ditherScale;
float densityFalloff;

float _RayOffset;
float _ShadowStrength;


float2 pixelPos(float2 uv)
{
    float width = _ScreenParams.x;
    float height = _ScreenParams.y;
				//float minDim = min(width, height);
    //float scale = 1000;
    float x = uv.x * width;
    float y = uv.y * height;
    return float2(x, y);
}

float2 blueNoiseUV(float2 uv)
{
    float2 pixel = pixelPos(uv);
    return pixel * _BlueNoise_TexelSize.xy;
}

// source https://www.shadertoy.com/view/4t2SDh
float nrand(float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);
}

// source https://www.shadertoy.com/view/4t2SDh
// Convert uniform distribution into triangle-shaped distribution.
float trangularDist(float nrnd0)
{
    float orig = nrnd0 * 2.0 - 1.0;
    nrnd0 = orig * rsqrt(abs(orig));
    nrnd0 = max(-1.0, nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!
    nrnd0 = nrnd0 - sign(orig);// +0.5;
    
    // Result is range [-0.5,1.5] which is
    // useful for actual dithering.
    return nrnd0;
}

float shadowAtPoint(float3 positionWorldSpace)
{
    float4 shadowCoord = TransformWorldToShadowCoord(positionWorldSpace);
    Light mainLight = GetMainLight(shadowCoord);

    float shadow = mainLight.shadowAttenuation;
    return shadow;
}
		
float densityAtPoint(float3 densitySamplePoint)
{
    float heightAboveSurface = length(densitySamplePoint - planetCentre) - planetRadius;
    float height01 = saturate(heightAboveSurface / (atmosphereRadius - planetRadius));
    float localDensity = exp(-height01 * densityFalloff) * (1 - height01);
    return localDensity;
}

		
float opticalDepth(float3 rayOrigin, float3 rayDir, float rayLength)
{
    const int numOpticalDepthPoints = 10;
    
    float3 densitySamplePoint = rayOrigin;
    float stepSize = rayLength / (numOpticalDepthPoints - 1);
    float opticalDepth = 0;
    float normalizedStepSize = stepSize / atmosphereRadius;

    for (int i = 0; i < numOpticalDepthPoints; i++)
    {
        float localDensity = densityAtPoint(densitySamplePoint);
        opticalDepth += localDensity;// * stepSize; ignoring stepSize makes this agnostic to planet radius
        densitySamplePoint += rayDir * stepSize;
    }
#ifdef FIXED_RAY_LENGTH
	return opticalDepth / numOpticalDepthPoints;
#else
    return opticalDepth * normalizedStepSize * 100;
#endif
}


float opticalDepthBaked(float3 rayOrigin, float3 rayDir)
{
    float height = length(rayOrigin - planetCentre) - planetRadius;
    float height01 = saturate(height / (atmosphereRadius - planetRadius));

    float uvX = 1 - (dot(normalize(rayOrigin - planetCentre), rayDir) * .5 + .5);
    return SAMPLE_TEXTURE2D_X_LOD(_BakedOpticalDepth, sampler_BakedOpticalDepth, float2(uvX, height01), 0);
}

float opticalDepthBaked2(float3 rayOrigin, float3 rayDir, float rayLength)
{
    float3 endPoint = rayOrigin + rayDir * rayLength;
    float d = dot(rayDir, normalize(rayOrigin - planetCentre));
    float opticalDepth = 0;

    const float blendStrength = 1.5;
    float w = saturate(d * blendStrength + .5);
    
    float d1 = opticalDepthBaked(rayOrigin, rayDir) - opticalDepthBaked(endPoint, rayDir);
    float d2 = opticalDepthBaked(endPoint, -rayDir) - opticalDepthBaked(rayOrigin, -rayDir);
    
    opticalDepth = lerp(d2, d1, w);
    return opticalDepth;

}

			
float3 calculateLight(float3 rayOrigin, float3 rayDir, float rayLength, float3 originalCol, float2 uv)
{
    float rand1 = nrand(float2(_Time.w, _SinTime.w));
    float blueNoise = SAMPLE_TEXTURE2D_X_LOD(_BlueNoise, sampler_BlueNoise, blueNoiseUV(uv + rand1) * ditherScale, 0);
				
    float stepSize = rayLength / (numInScatteringPoints);
    float3 stepVec = rayDir * stepSize;
    float3 randomOffset = blueNoise * stepVec * _RayOffset;
    float3 inScatterPoint = rayOrigin + randomOffset;
    float3 inScatteredLight = 0;
    float viewRayOpticalDepth = 0;

#ifdef FIXED_RAY_LENGTH
    float normalizedStepSize = 1 / numInScatteringPoints;
#else
    float normalizedStepSize = stepSize / atmosphereRadius * 100;
#endif

    
    float3 dirToSun = _MainLightPosition.xyz;

    for (int i = 0; i < numInScatteringPoints; i++)
    {
        float sunRayLength = raySphere(planetCentre, atmosphereRadius, inScatterPoint, dirToSun).y;
        float sunRayOpticalDepth = opticalDepthBaked(inScatterPoint, dirToSun);
        float localDensity = densityAtPoint(inScatterPoint);
        viewRayOpticalDepth += localDensity * normalizedStepSize;
        float3 transmittance = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * scatteringCoefficients.xyz);
        float shadow = lerp(1, shadowAtPoint(inScatterPoint), _ShadowStrength);
        
        inScatteredLight += localDensity * transmittance * shadow;
        inScatterPoint += stepVec;
    }
    inScatteredLight *= scatteringCoefficients.xyz * intensity * stepSize;// / planetRadius;

    
				// Attenuate brightness of original col (i.e light reflected from planet surfaces)
				// This is a hacky mess, TODO: figure out a proper way to do this
    /*
    const float brightnessAdaptionStrength = 0.15;
    const float reflectedLightOutScatterStrength = 3;
    float brightnessAdaption = dot(inScatteredLight, 1) * brightnessAdaptionStrength;
    float brightnessSum = viewRayOpticalDepth * intensity * reflectedLightOutScatterStrength + brightnessAdaption;
    float reflectedLightStrength = exp(-brightnessSum);
    float hdrStrength = saturate(dot(originalCol, 1) / 3 - 1);
    reflectedLightStrength = lerp(reflectedLightStrength, 1, hdrStrength);
    float3 reflectedLight = originalCol * reflectedLightStrength;
*/

    float3 finalCol = inScatteredLight + originalCol;
    //float3 finalCol = inScatteredLight + reflectedLight;

    return finalCol;
}



float4 frag(v2f i) : SV_Target
{

    float4 originalCol = SAMPLE_TEXTURE2D_X_LOD(_MainTex, sampler_MainTex, i.uv, 0);
    float sceneDepthNonLinear = SampleSceneDepth(i.uv);
    float sceneDepth = LinearEyeDepth(sceneDepthNonLinear, _ZBufferParams) * length(i.viewVector);
				//return sceneDepth;
				
    float3 rayOrigin = _WorldSpaceCameraPos;
    float3 rayDir = normalize(i.viewVector);
				
    float dstToOcean = raySphere(planetCentre, oceanRadius, rayOrigin, rayDir);
    float dstToSurface = min(sceneDepth, dstToOcean);
				
    float2 hitInfo = raySphere(planetCentre, atmosphereRadius, rayOrigin, rayDir);
    float dstToAtmosphere = hitInfo.x;
    float dstThroughAtmosphere = min(hitInfo.y, dstToSurface - dstToAtmosphere);
				
    if (dstThroughAtmosphere > 0)
    {
        const float epsilon = 0.0001;
        float3 pointInAtmosphere = rayOrigin + rayDir * (dstToAtmosphere + epsilon);
        float3 light = calculateLight(pointInAtmosphere, rayDir, dstThroughAtmosphere - epsilon * 2, originalCol.xyz, i.uv);
        return float4(light, 1);
    }
    return originalCol;
}
