#pragma kernel CSMain
#include "Math.hlsl"

#pragma multi_compile _ FIXED_RAY_LENGTH

RWTexture2D<float4> Result;
int textureSize;
int numOutScatteringSteps;
float avgDensityHeight01;
float densityFalloff;
float4 params;



float densityAtPoint(float2 densitySamplePoint)
{
    const float atmosphereRadius = 2;
    const float planetRadius = 1;
	const float2 planetCentre = 0;

	float heightAboveSurface = length(densitySamplePoint - planetCentre) - planetRadius;
	float height01 = heightAboveSurface / (atmosphereRadius - planetRadius);
    float localDensity = exp(-height01 * densityFalloff) * (1 - height01);
	return localDensity;
}

float opticalDepth(float2 rayOrigin, float2 rayDir, float rayLength)
{
    const float atmosphereRadius = 2;
    const float planetRadius = 1;
	
    const int numOpticalDepthPoints = 10;

	float2 densitySamplePoint = rayOrigin;
	float stepSize = rayLength / (numOpticalDepthPoints - 1);
	float opticalDepth = 0;
    float normalizedStepSize = stepSize / atmosphereRadius;
	
	for (int i = 0; i < numOpticalDepthPoints; i ++) {
		float localDensity = densityAtPoint(densitySamplePoint);
        opticalDepth += localDensity;// * stepSize;
		densitySamplePoint += rayDir * stepSize;
	}
#ifdef FIXED_RAY_LENGTH
	return opticalDepth / numOpticalDepthPoints;
#else
    return opticalDepth * normalizedStepSize * 100;
#endif
}



[numthreads(8,8,1)]
void CSMain (uint2 id : SV_DispatchThreadID)
{
    const float atmosphereRadius = 2;
    const float planetRadius = 1;
	
	float2 uv = id / (float)textureSize;
	float height01 = uv.y;
	float y = -2 * uv.x + 1;
	float x = sin(acos(y));
	float2 dir = float2(x,y);
	
	float2 inPoint = float2(0, lerp(planetRadius, atmosphereRadius, height01));
	float dstThroughAtmosphere = raySphere(0, atmosphereRadius, float3(inPoint,0), float3(dir,0)).y;
    float2 outPoint = inPoint + dir * dstThroughAtmosphere;
	float outScattering = opticalDepth(inPoint + dir * 0.0001, dir, dstThroughAtmosphere-0.0002);

	Result[id.xy] = outScattering;
}
